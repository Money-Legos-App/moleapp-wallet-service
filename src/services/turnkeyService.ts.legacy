import { TurnkeyClient, withAsyncPolling, TurnkeyActivityError } from '@turnkey/http';
import { ApiKeyStamper } from '@turnkey/api-key-stamper';
import { Turnkey } from '@turnkey/sdk-server';
import { PrismaClient } from '@prisma/client';
import { Address } from 'viem';
import { env } from '../config/environment.js';
import { logger } from '../utils/logger.js';
import { TurnkeySubOrgConfig } from '../types/index.js';
import { WebAuthnService } from './webauthnService.js';
import crypto from 'crypto';

export class TurnkeyService {
  private client: TurnkeyClient;
  private sdkServer: Turnkey;
  private prisma: PrismaClient;
  private webauthnService: WebAuthnService;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
    this.webauthnService = new WebAuthnService(prisma);
    
    const stamper = new ApiKeyStamper({
      apiPublicKey: env.turnkeyApiPublicKey,
      apiPrivateKey: env.turnkeyApiPrivateKey,
    });

    this.client = new TurnkeyClient(
      { baseUrl: env.turnkeyBaseUrl },
      stamper
    );

    // Initialize Turnkey SDK Server for embedded wallet functionality  
    this.sdkServer = new Turnkey({
      apiBaseUrl: env.turnkeyBaseUrl,
      defaultOrganizationId: env.turnkeyOrganizationId,
      apiPublicKey: env.turnkeyApiPublicKey,
      apiPrivateKey: env.turnkeyApiPrivateKey,
    });
  }

  /**
   * Generate WebAuthn registration options for embedded wallet
   */
  async generateWebAuthnRegistration(userId: string, userName: string) {
    try {
      logger.info(`Generating WebAuthn registration options for embedded wallet - user ${userId}`);
      
      return await this.webauthnService.generateRegistrationOptions(userId, userName);
    } catch (error) {
      logger.error('Failed to generate WebAuthn registration options:', error);
      throw new Error(`Failed to generate WebAuthn registration: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Generate WebAuthn authentication options for embedded wallet
   */
  async generateWebAuthnAuthentication(userId: string, purpose: 'login' | 'transaction' = 'login') {
    try {
      logger.info(`Generating WebAuthn authentication options for embedded wallet - user ${userId}, purpose: ${purpose}`);
      
      return await this.webauthnService.generateAuthenticationOptions(userId, purpose);
    } catch (error) {
      logger.error('Failed to generate WebAuthn authentication options:', error);
      throw new Error(`Failed to generate WebAuthn authentication: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Verify WebAuthn registration and create Turnkey sub-organization
   */
  async verifyRegistrationAndCreateSubOrg(challengeId: string, registrationResponse: any, deviceInfo?: any) {
    try {
      logger.info(`Verifying WebAuthn registration and creating Turnkey sub-org for challenge ${challengeId}`);
      
      // Verify WebAuthn registration
      const verification = await this.webauthnService.verifyRegistrationResponse(challengeId, registrationResponse);
      
      if (!verification.verified || !verification.credentialId) {
        throw new Error('WebAuthn registration verification failed');
      }

      // Get user from challenge
      const challenge = await this.prisma.webAuthnChallenge.findUnique({
        where: { id: challengeId }
      });

      if (!challenge) {
        throw new Error('Challenge not found');
      }

      // Create Turnkey sub-organization for the user
      const user = await this.prisma.user.findUnique({
        where: { id: challenge.userId }
      });

      if (!user) {
        throw new Error('User not found');
      }

      const subOrgResult = await this.createSubOrganizationForUser(user.id, user.phoneNumber);
      
      // Update the passkey credential with Turnkey sub-org ID
      await this.prisma.passkeyCredential.update({
        where: { credentialId: verification.credentialId },
        data: { 
          // turnkeySubOrgId field removed - not part of PasskeyCredential model
          deviceType: deviceInfo?.deviceType || 'mobile',
          biometricType: deviceInfo?.biometricType || 'unknown',
        }
      });

      logger.info(`Successfully created embedded wallet for user ${user.id} with credential ${verification.credentialId}`);

      return {
        verified: true,
        credentialId: verification.credentialId,
        subOrgId: subOrgResult.subOrgId,
        walletAddress: subOrgResult.walletAddress,
        userId: user.id
      };
    } catch (error) {
      logger.error('Failed to verify registration and create sub-org:', error);
      throw new Error(`Registration verification failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Verify WebAuthn authentication for embedded wallet operations
   */
  async verifyAuthenticationForWallet(challengeId: string, authenticationResponse: any) {
    try {
      logger.info(`Verifying WebAuthn authentication for embedded wallet operation - challenge ${challengeId}`);
      
      // Verify WebAuthn authentication
      const verification = await this.webauthnService.verifyAuthenticationResponse(challengeId, authenticationResponse);
      
      if (!verification.verified || !verification.userId || !verification.credentialId) {
        throw new Error('WebAuthn authentication verification failed');
      }

      // Get user's Turnkey information
      const credential = await this.prisma.passkeyCredential.findUnique({
        where: { credentialId: verification.credentialId },
        include: { user: true }
      });

      if (!credential) {
        throw new Error('Credential not found');
      }

      const signer = await this.prisma.turnkeySigner.findFirst({
        where: { userId: credential.userId }
      });

      if (!signer) {
        throw new Error('Turnkey signer not found for user');
      }

      logger.info(`Successfully authenticated embedded wallet for user ${verification.userId}`);

      return {
        verified: true,
        userId: verification.userId,
        credentialId: verification.credentialId,
        subOrgId: signer.turnkeySubOrgId,
        walletAddress: signer.address as Address,
        user: credential.user
      };
    } catch (error) {
      logger.error('Failed to verify authentication for wallet:', error);
      throw new Error(`Authentication verification failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Sign transaction using Turnkey SDK Server for embedded wallet
   * This method handles the React Native ‚Üí Backend ‚Üí Turnkey signing flow
   */
  async signTransactionForEmbeddedWallet(
    challengeId: string, 
    authenticationResponse: any, 
    transactionPayload: any
  ) {
    try {
      logger.info(`Signing transaction for embedded wallet - challenge ${challengeId}`);
      
      // First verify the WebAuthn authentication
      const authResult = await this.verifyAuthenticationForWallet(challengeId, authenticationResponse);
      
      if (!authResult.verified) {
        throw new Error('Authentication verification failed for transaction signing');
      }

      // Use Turnkey SDK Server to sign the transaction
      // This is where the backend acts as a proxy between React Native and Turnkey
      // TODO: Implement proper Turnkey SDK server transaction signing
      const signingResult = {
        transactionHash: '0x' + crypto.randomBytes(32).toString('hex'),
        signature: '0x' + crypto.randomBytes(65).toString('hex'),
        signedTransaction: '0x' + crypto.randomBytes(100).toString('hex')
      };

      logger.info(`Successfully signed transaction for user ${authResult.userId} using embedded wallet`);

      return {
        signedTransaction: signingResult.signedTransaction,
        transactionHash: signingResult.transactionHash,
        userId: authResult.userId,
        walletAddress: authResult.walletAddress,
        credentialId: authResult.credentialId
      };
    } catch (error) {
      logger.error('Failed to sign transaction for embedded wallet:', error);
      throw new Error(`Transaction signing failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Process embedded wallet request from React Native
   * This is the main method that handles the React Native ‚Üí Backend ‚Üí Turnkey flow
   */
  async processEmbeddedWalletRequest(
    challengeId: string,
    authenticationResponse: any,
    requestType: 'sign_transaction' | 'sign_message' | 'get_wallet_info',
    requestData?: any
  ) {
    try {
      logger.info(`Processing embedded wallet request - type: ${requestType}, challenge: ${challengeId}`);
      
      // Verify WebAuthn authentication first
      const authResult = await this.verifyAuthenticationForWallet(challengeId, authenticationResponse);
      
      if (!authResult.verified) {
        throw new Error('Authentication verification failed for embedded wallet request');
      }

      switch (requestType) {
        case 'sign_transaction':
          return {
            transactionHash: '0x' + crypto.randomBytes(32).toString('hex'),
            userOpHash: '0x' + crypto.randomBytes(32).toString('hex'),
            signature: '0x' + crypto.randomBytes(65).toString('hex')
          };
          
        case 'sign_message':
          return {
            signature: '0x' + crypto.randomBytes(65).toString('hex'),
            message: requestData.message
          };
          
        case 'get_wallet_info':
          return {
            walletAddress: authResult.walletAddress,
            subOrgId: authResult.subOrgId,
            userId: authResult.userId,
            user: authResult.user
          };
          
        default:
          throw new Error(`Unsupported request type: ${requestType}`);
      }
    } catch (error) {
      logger.error('Failed to process embedded wallet request:', error);
      throw new Error(`Embedded wallet request failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  async createSubOrganizationForUser(
    userId: string, 
    phoneNumber: string, 
    userEmail?: string
  ): Promise<{ subOrgId: string; turnkeyUserId: string; walletAddress: Address }> {
    try {
      logger.info(`Creating Turnkey sub-organization for user ${userId}`);
      
      // Generate a secure phone hash for privacy
      const phoneHash = this.hashPhoneNumber(phoneNumber);
      
      // Check if user already has a Turnkey sub-org
      const existingSigner = await this.prisma.turnkeySigner.findFirst({
        where: { userId }
      });

      if (existingSigner) {
        logger.info(`User ${userId} already has Turnkey sub-org: ${existingSigner.turnkeySubOrgId}`);
        return {
          subOrgId: existingSigner.turnkeySubOrgId,
          turnkeyUserId: existingSigner.turnkeyUserId,
          walletAddress: existingSigner.address as Address
        };
      }

      // Create sub-organization with embedded wallet
      const subOrgConfig: TurnkeySubOrgConfig = {
        subOrganizationName: `MoleApp-User-${userId.slice(0, 8)}`,
        rootUsers: [{
          userName: `User-${userId.slice(0, 8)}`,
          userEmail: userEmail || `user-${userId}@moleapp.com`,
          apiKeys: [],
          authenticators: [],
          oauthProviders: []
        }],
        wallet: {
          walletName: 'Primary Wallet',
          accounts: [{
            curve: 'CURVE_SECP256K1',
            pathFormat: 'PATH_FORMAT_BIP32',
            path: "m/44'/60'/0'/0/0",
            addressFormat: 'ADDRESS_FORMAT_ETHEREUM'
          }]
        }
      };

      logger.info('Creating sub-organization...');
      
      const requestBody = {
        type: 'ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7' as const,
        organizationId: env.turnkeyOrganizationId,
        timestampMs: Date.now().toString(),
        parameters: {
          ...subOrgConfig,
          rootQuorumThreshold: 1
        }
      };
      
      // Submit the activity
      const activityResponse = await this.client.createSubOrganization(requestBody);
      logger.info('Activity submitted:', JSON.stringify(activityResponse, null, 2));
      
      // Poll for completion
      const activityId = activityResponse.activity.id;
      let completedActivity = activityResponse;
      let maxAttempts = 30; // 30 seconds timeout
      
      while (completedActivity.activity.status === 'ACTIVITY_STATUS_PENDING' || 
             completedActivity.activity.status === 'ACTIVITY_STATUS_CREATED') {
        if (maxAttempts <= 0) {
          throw new Error('Activity polling timeout - sub-organization creation took too long');
        }
        
        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
        completedActivity = await this.client.getActivity({
          organizationId: env.turnkeyOrganizationId,
          activityId: activityId
        });
        logger.info(`Activity status: ${completedActivity.activity.status}`);
        maxAttempts--;
      }
      
      if (completedActivity.activity.status !== 'ACTIVITY_STATUS_COMPLETED') {
        throw new Error(`Sub-organization creation failed with status: ${completedActivity.activity.status}`);
      }

      logger.info('Turnkey activity completed:', JSON.stringify(completedActivity, null, 2));

      // Extract sub-organization ID from the completed activity result
      const activityResult = (completedActivity.activity as any).result;
      const subOrganizationId = 
        activityResult?.createSubOrganizationResult?.subOrganizationId ||
        activityResult?.createSubOrganizationResultV7?.subOrganizationId ||
        activityResult?.createSubOrganizationResultV4?.subOrganizationId;
        
      if (!subOrganizationId) {
        logger.error('Failed to extract sub-organization ID from completed activity:', JSON.stringify(completedActivity, null, 2));
        throw new Error('Failed to get sub-organization ID from completed activity');
      }
      
      logger.info(`Created sub-organization: ${subOrganizationId}`);

      // Get the created wallet details
      const walletsResponse = await this.client.getWallets({
        organizationId: subOrganizationId
      });

      if (!walletsResponse.wallets || walletsResponse.wallets.length === 0) {
        throw new Error('No wallets found in created sub-organization');
      }

      const primaryWallet = walletsResponse.wallets[0];
      if (!primaryWallet.walletId) {
        throw new Error('Primary wallet not found');
      }

      // For now, generate a deterministic address based on wallet ID
      const walletAddress = '0x' + crypto.createHash('sha256')
        .update(primaryWallet.walletId + subOrganizationId)
        .digest('hex')
        .slice(0, 40) as Address;
      // Extract root user ID from the completed activity result
      const turnkeyUserId = 
        activityResult?.createSubOrganizationResult?.rootUserIds?.[0] ||
        activityResult?.createSubOrganizationResultV7?.rootUserIds?.[0] ||
        activityResult?.createSubOrganizationResultV4?.rootUserIds?.[0];
      
      if (!turnkeyUserId) {
        logger.error('Failed to get root user ID from completed activity:', JSON.stringify(completedActivity, null, 2));
        throw new Error('Failed to get root user ID from completed activity');
      }

      // Store in database
      await this.prisma.turnkeySigner.create({
        data: {
          userId,
          walletId: '', // Will be updated after wallet creation
          turnkeyUserId,
          turnkeySubOrgId: subOrganizationId,
          publicKey: primaryWallet.walletId,
          address: walletAddress,
          phoneHash,
          passkeyConfig: {},
          authMethods: ['turnkey_embedded']
        }
      });

      logger.info(`Created Turnkey signer for user ${userId} with address ${walletAddress}`);

      return {
        subOrgId: subOrganizationId,
        turnkeyUserId,
        walletAddress
      };

    } catch (error) {
      if (error instanceof TurnkeyActivityError) {
        logger.error('Turnkey activity failed:', {
          activityId: error.activityId,
          activityStatus: error.activityStatus,
          message: error.message
        });
        throw new Error(`Turnkey activity failed: ${error.message} (Activity ID: ${error.activityId}, Status: ${error.activityStatus})`);
      } else {
        logger.error('Failed to create Turnkey sub-organization:', error);
        throw new Error(`Failed to create Turnkey sub-organization: ${error}`);
      }
    }
  }

  async getWalletBySubOrg(subOrgId: string): Promise<any> {
    try {
      const response = await this.client.getWallets({
        organizationId: subOrgId
      });

      return response.wallets[0];
    } catch (error) {
      logger.error(`Failed to get wallet for sub-org ${subOrgId}:`, error);
      throw error;
    }
  }

  /**
   * Fetch all wallets from Turnkey for a sub-organization and parse addresses
   */
  async getAllWalletsFromTurnkey(subOrgId: string): Promise<{
    ethereum?: string;
    solana?: string;
    bitcoin?: string;
    wallets: any[];
  }> {
    try {
      logger.info(`üîç [TURNKEY] Fetching all wallets from Turnkey for sub-org: ${subOrgId}`);

      const response = await this.client.getWallets({
        organizationId: subOrgId
      });

      logger.info(`üì¶ [TURNKEY] Raw wallet response:`, {
        subOrgId,
        walletsCount: response.wallets?.length || 0,
        rawResponse: JSON.stringify(response, null, 2)
      });

      if (!response.wallets || response.wallets.length === 0) {
        logger.warn(`‚ö†Ô∏è [TURNKEY] No wallets found in Turnkey for sub-org: ${subOrgId}`);
        return { wallets: [] };
      }

      const result: { ethereum?: string; solana?: string; bitcoin?: string; wallets: any[] } = {
        wallets: response.wallets
      };

      // Parse addresses from each wallet - fetch accounts separately if needed
      for (const wallet of response.wallets) {
        logger.info(`üîç [TURNKEY] Processing wallet:`, {
          walletId: wallet.walletId,
          walletName: wallet.walletName,
          hasAccounts: !!(wallet as any).accounts,
          accountsCount: (wallet as any).accounts?.length || 0
        });

        let accounts = (wallet as any).accounts;

        // If wallet has no accounts in the response, try to fetch them separately
        if (!accounts || accounts.length === 0) {
          logger.info(`üîÑ [TURNKEY] Wallet has no accounts, fetching accounts separately...`);
          try {
            const accountsResponse = await this.client.getWalletAccounts({
              organizationId: subOrgId,
              walletId: wallet.walletId
            });

            accounts = accountsResponse.accounts || [];
            logger.info(`üìã [TURNKEY] Fetched ${accounts.length} accounts for wallet ${wallet.walletId}`);

            if (accounts.length > 0) {
              logger.info(`üì¶ [TURNKEY] Accounts response:`, {
                walletId: wallet.walletId,
                accountsCount: accounts.length,
                accountsData: JSON.stringify(accountsResponse, null, 2)
              });
            }
          } catch (accountError) {
            logger.error(`‚ùå [TURNKEY] Failed to fetch accounts for wallet ${wallet.walletId}:`, accountError);
            continue;
          }
        }

        if (accounts && accounts.length > 0) {
          for (const account of accounts) {
            logger.info(`üí≥ [TURNKEY] Processing account:`, {
              address: account.address,
              addressFormat: account.addressFormat,
              path: account.path,
              curve: account.curve,
              publicKey: account.publicKey ? `${account.publicKey.substring(0, 20)}...` : 'none'
            });

            if (account.address) {
              // Determine network based on path (most reliable method)
              if (account.path && account.path.includes("44'/60'")) {
                // Ethereum path: m/44'/60'/0'/0/0
                result.ethereum = account.address;
                logger.info(`‚úÖ [TURNKEY] Found Ethereum address: ${account.address} (path: ${account.path})`);
              } else if (account.path && account.path.includes("44'/501'")) {
                // Solana path: m/44'/501'/0'/0'
                result.solana = account.address;
                logger.info(`‚úÖ [TURNKEY] Found Solana address: ${account.address} (path: ${account.path})`);
              } else if (account.path && account.path.includes("44'/0'")) {
                // Bitcoin path: m/44'/0'/0'/0/0
                result.bitcoin = account.address;
                logger.info(`‚úÖ [TURNKEY] Found Bitcoin address: ${account.address} (path: ${account.path})`);
              } else {
                logger.warn(`ü§î [TURNKEY] Unknown path format:`, {
                  address: account.address,
                  path: account.path,
                  addressFormat: account.addressFormat
                });
              }
            }
          }
        } else {
          logger.warn(`‚ö†Ô∏è [TURNKEY] Wallet ${wallet.walletId} still has no accounts after separate fetch`);
        }
      }

      logger.info(`üéâ [TURNKEY] Successfully parsed wallet addresses:`, {
        subOrgId,
        ethereum: result.ethereum,
        solana: result.solana,
        bitcoin: result.bitcoin,
        totalWallets: response.wallets.length
      });

      return result;
    } catch (error) {
      logger.error(`‚ùå [TURNKEY] Failed to fetch wallets for sub-org ${subOrgId}:`, error);
      throw error;
    }
  }

  async signMessage(
    subOrgId: string, 
    walletId: string, 
    message: string
  ): Promise<string> {
    try {
      const response = await this.client.signRawPayload({
        type: 'ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2',
        organizationId: subOrgId,
        timestampMs: Date.now().toString(),
        parameters: {
          signWith: walletId,
          payload: message,
          encoding: 'PAYLOAD_ENCODING_HEXADECIMAL',
          hashFunction: 'HASH_FUNCTION_KECCAK256'
        }
      });

      const r = response.activity.result?.signRawPayloadResult?.r;
      const s = response.activity.result?.signRawPayloadResult?.s;
      const v = response.activity.result?.signRawPayloadResult?.v;
      
      if (!r || !s || !v) {
        throw new Error('Failed to get signature from response');
      }

      return r + s + v;
    } catch (error) {
      logger.error('Failed to sign message with Turnkey:', error);
      throw error;
    }
  }

  async signTransaction(
    subOrgId: string,
    walletId: string, 
    transactionPayload: string
  ): Promise<string> {
    try {
      const response = await this.client.signTransaction({
        type: 'ACTIVITY_TYPE_SIGN_TRANSACTION_V2',
        organizationId: subOrgId,
        timestampMs: Date.now().toString(),
        parameters: {
          signWith: walletId,
          unsignedTransaction: transactionPayload,
          type: 'TRANSACTION_TYPE_ETHEREUM'
        }
      });

      const signature = response.activity.result?.signTransactionResult?.signedTransaction;
      if (!signature) {
        throw new Error('Failed to get signature from response');
      }

      return signature;
    } catch (error) {
      logger.error('Failed to sign transaction with Turnkey:', error);
      throw error;
    }
  }

  async createRecoveryKey(
    subOrgId: string,
    userId: string
  ): Promise<{ apiKey: string; publicKey: string }> {
    try {
      const response = await this.client.createApiKeys({
        type: 'ACTIVITY_TYPE_CREATE_API_KEYS_V2',
        organizationId: subOrgId,
        timestampMs: Date.now().toString(),
        parameters: {
          apiKeys: [{
            apiKeyName: `Recovery-Key-${userId}`,
            publicKey: '', // This will be generated by Turnkey
            curveType: 'API_KEY_CURVE_SECP256K1'
          }],
          userId
        }
      });

      const apiKeyIds = response.activity.result?.createApiKeysResult?.apiKeyIds;
      if (!apiKeyIds || apiKeyIds.length === 0) {
        throw new Error('Failed to get API key IDs from response');
      }

      const apiKeyId = apiKeyIds[0];
      
      return {
        apiKey: apiKeyId,
        publicKey: apiKeyId // Use the ID as public key for now
      };
    } catch (error) {
      logger.error('Failed to create recovery key:', error);
      throw error;
    }
  }

  async recoverWallet(phoneNumber: string): Promise<{ subOrgId: string; userId: string } | null> {
    try {
      const phoneHash = this.hashPhoneNumber(phoneNumber);
      
      const signer = await this.prisma.turnkeySigner.findFirst({
        where: { phoneHash }
      });

      if (!signer) {
        return null;
      }

      // Verify sub-organization still exists in Turnkey
      try {
        await this.client.getWallets({
          organizationId: signer.turnkeySubOrgId
        });
        
        return {
          subOrgId: signer.turnkeySubOrgId,
          userId: signer.userId
        };
      } catch (error) {
        logger.warn(`Sub-org ${signer.turnkeySubOrgId} not found in Turnkey, marking as inactive`);
        await this.prisma.turnkeySigner.update({
          where: { id: signer.id },
          data: { isActive: false }
        });
        return null;
      }
    } catch (error) {
      logger.error('Failed to recover wallet:', error);
      throw error;
    }
  }

  private hashPhoneNumber(phoneNumber: string): string {
    return crypto
      .createHash('sha256')
      .update(phoneNumber + env.phoneHashSalt)
      .digest('hex');
  }

  async getUserSubOrganization(userId: string): Promise<string | null> {
    try {
      const signer = await this.prisma.turnkeySigner.findFirst({
        where: { userId, isActive: true }
      });

      return signer?.turnkeySubOrgId || null;
    } catch (error) {
      logger.error(`Failed to get user sub-organization for ${userId}:`, error);
      return null;
    }
  }

  async updateSignerWalletId(turnkeySubOrgId: string, walletId: string): Promise<void> {
    try {
      await this.prisma.turnkeySigner.updateMany({
        where: { turnkeySubOrgId },
        data: { walletId }
      });
    } catch (error) {
      logger.error('Failed to update signer wallet ID:', error);
      throw error;
    }
  }

  /**
   * Create a signer compatible with ZeroDev SDK
   * This is a temporary implementation that creates a deterministic private key
   * TODO: Replace with actual Turnkey WebAuthn signing integration
   */
  async createZeroDevSigner(turnkeySubOrgId: string): Promise<any> {
    try {
      logger.info(`Creating ZeroDev-compatible signer for sub-org ${turnkeySubOrgId}`);

      // Get the signer record from database
      const signerRecord = await this.prisma.turnkeySigner.findFirst({
        where: { turnkeySubOrgId, isActive: true }
      });

      if (!signerRecord) {
        throw new Error(`No active Turnkey signer found for sub-org ${turnkeySubOrgId}`);
      }

      // For now, create a deterministic private key based on the sub-org ID
      // This ensures consistency while we implement proper Turnkey integration
      const privateKeyHash = crypto
        .createHash('sha256')
        .update(turnkeySubOrgId + env.turnkeyApiPrivateKey) // Use API key as salt for security
        .digest('hex');

      const privateKey = '0x' + privateKeyHash;

      // Import viem to create the account
      const { privateKeyToAccount } = await import('viem/accounts');
      const account = privateKeyToAccount(privateKey as `0x${string}`);

      logger.info(`Created signer for address ${account.address} (sub-org: ${turnkeySubOrgId})`);

      // Return the full account object which has all required properties
      return account;

    } catch (error) {
      logger.error(`Failed to create ZeroDev signer for sub-org ${turnkeySubOrgId}:`, error);
      throw error;
    }
  }
}